max_axis_x <- max(df$predicted)
range_y <- diff(range(df$distance))
min_axis_y <- min(df$distance) - range_y*0.1
max_axis_y <- max(df$distance) + range_y*0.1
model <- stats::lm(data$distance ~ data$predicted)
r2 <- format(summary(model)$r.squared, digits=2, nsmall = 2)
r2lab <- bquote(paste(italic(R^2), " = ", .(r2), sep=""))
intercept <- format(summary(model)$coefficients[1,1], digits=2, nsmall = 2)
coefficient <- format(summary(model)$coefficients[2,1], digits=2, nsmall = 2)
equationlab <- bquote(paste(italic(y), " = ", .(intercept), " + ", .(coefficient), " ", italic(x), sep=""))
if(as.numeric(coefficient) < 0){
coefficient <- format(-summary(model)$coefficients[2,1], digits=2, nsmall = 2)
equationlab <- bquote(paste(italic(y), " = ", .(intercept), " - ", .(coefficient), " ", italic(x), sep=""))
}
glist[[length(cell_list) + 1]] <- ggplot(data, aes(x=predicted, y=distance)) +
geom_smooth(method="lm", color = "steelblue", fill = "steelblue") +
geom_point(size=0.8, alpha=0.5) +
annotate("text", x=min_axis_x+range_x*0.02, y=max_axis_y-range_y*0.05,
label=equationlab, size=ps/ggplot2::.pt, hjust = 0) +
annotate("text", x=min_axis_x+range_x*0.02, y=max_axis_y-range_y*0.17,
label=r2lab, size=ps/ggplot2::.pt, hjust = 0) +
coord_cartesian(xlim=c(min_axis_x, max_axis_x), ylim=c(min_axis_y, max_axis_y), clip='on') +
theme_plot2 +
theme(plot.title = element_text(size=ps, face = "bold"),
axis.title=element_text(size=ps),
axis.text=element_text(size=ps),
plot.tag = element_text(size = 12, face = "bold"),
plot.margin=unit(c(3,3,3,3), 'mm')) +
labs(title = titles,
x=label_x,
y = label_y)
}
length(cell_list) != 1
## Plotting for all cells
# Title of the plots
if(length(cell_list) != 1){
titles <- paste0("All ", stringr::str_to_lower(df_name), "s")
data <- df
range_x <- diff(range(df$predicted))
min_axis_x <- min(df$predicted)
max_axis_x <- max(df$predicted)
range_y <- diff(range(df$distance))
min_axis_y <- min(df$distance) - range_y*0.1
max_axis_y <- max(df$distance) + range_y*0.1
#model <- stats::lm(data$distance ~ data$predicted)
model <- RobustLinearReg::siegel_regression(distance ~ predicted, data = data)
newx = seq(min(data$predicted), max(data$predicted), by = 0.1)
suppressWarnings(conf_interval <- stats::predict(model, interval="confidence", level = 0.95))
conf_interval2 <- as.data.frame(cbind(data$predicted, conf_interval)[order(data$predicted, decreasing = F),])
names(conf_interval2)[1] <- "predicted"
## Plotting
r2 <- format(summary(model)$r.squared, digits=2, nsmall = 2)
r2lab <- bquote(paste(italic(R^2), " = ", .(r2), sep=""))
intercept <- format(summary(model)$coefficients[1,1], digits=2, nsmall = 2)
coefficient <- format(summary(model)$coefficients[2,1], digits=2, nsmall = 2)
equationlab <- bquote(paste(italic(y), " = ", .(intercept), " + ", .(coefficient), " ", italic(x), sep=""))
if(as.numeric(coefficient) < 0){
coefficient <- format(-summary(model)$coefficients[2,1], digits=2, nsmall = 2)
equationlab <- bquote(paste(italic(y), " = ", .(intercept), " - ", .(coefficient), " ", italic(x), sep=""))
}
glist[[length(cell_list) + 1]] <- ggplot() +
geom_line(data = conf_interval2, aes(x=predicted, y=fit), color = "steelblue", linewidth = 1) +
geom_ribbon(data = conf_interval2, aes(x=predicted, ymin = lwr, ymax = upr), alpha = 0.4, fill = "steelblue") +
geom_point(data = data, aes(x=predicted, y=distance), size=0.8, alpha=0.5) +
annotate("text", x=min_axis_x+range_x*0.02, y=max_axis_y-range_y*0.05,
label=equationlab, size=ps/ggplot2::.pt, hjust = 0) +
annotate("text", x=min_axis_x+range_x*0.02, y=max_axis_y-range_y*0.17,
label=r2lab, size=ps/ggplot2::.pt, hjust = 0) +
coord_cartesian(xlim=c(min_axis_x, max_axis_x), ylim=c(min_axis_y, max_axis_y), clip='on') +
theme_plot2 +
theme(plot.title = element_text(size=ps, face = "bold"),
axis.title=element_text(size=ps),
axis.text=element_text(size=ps),
plot.tag = element_text(size = 12, face = "bold"),
plot.margin=unit(c(3,3,3,3), 'mm')) +
labs(title = titles,
x=label_x,
y = label_y)
}
if(length(cell_list) != 1){
# Speed of all cells
lm_allcells <- RobustLinearReg::siegel_regression(distance ~ predicted, data = df)
# Speed of each cell
ydiff <- 1 / (length(cell_list) + 1)
g_speed <- ggplot() + theme_void()
for(i in 1:length(cell_list)){
lm_cell <- RobustLinearReg::siegel_regression(formula = distance~predicted, data = df[df[,1]==i,])
# label
title_all <- paste0("All ", stringr::str_to_lower(df_name), "s")
title_each <- paste(stringr::str_to_title(df_name), " ", i, sep="")
if(unit1=="meter"){
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (m/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (m/.(unit2)), sep = ""))
}else if(unit1=="centimeter"){
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (cm/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (cm/.(unit2)), sep = ""))
}else if(unit1=="millimeter"){
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (mm/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (mm/.(unit2)), sep = ""))
}else if(unit1=="micrometer"){
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (mu*m/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (mu*m/.(unit2)), sep = ""))
}else if(unit1=="nanometer"){
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (nm/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (nm/.(unit2)), sep = ""))
}else{
label_all <- bquote(paste(.(title_all), ":  ", .(round(lm_allcells$coefficients[2], 2)), " ", (.(unit1)/.(unit2)), sep = ""))
label_each <- bquote(paste(.(title_each), ":  ", .(round(lm_cell$coefficients[2], 2)), " ", (.(unit1)/.(unit2)), sep = ""))
}
g_speed <- g_speed +
annotate("text", x = 0.5, y = 1 - ydiff*i,
label = label_each,
size = ps/ggplot2::.pt)
}
# Speed of all cells
g_speed <- g_speed +
coord_cartesian(xlim=c(0,1), ylim=c(0,1), clip='off') +
annotate("text", x=0.5, y=1.0,
label="Signal transfer speed",
size=ps/ggplot2::.pt, fontface = 2) +
annotate("text", x=0.5, y=0.0,
label = label_all,
size=ps/ggplot2::.pt)
glist[[length(cell_list) + 2]] <- g_speed
}else{
g_speed <- ggplot() + theme_void()
lm_cell <- RobustLinearReg::siegel_regression(formula = distance~predicted, data = df)
if(unit1=="meter"){
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (m/.(unit2)), sep = ""))
}else if(unit1=="centimeter"){
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (cm/.(unit2)), sep = ""))
}else if(unit1=="millimeter"){
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (mm/.(unit2)), sep = ""))
}else if(unit1=="micrometer"){
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (mu*m/.(unit2)), sep = ""))
}else if(unit1=="nanometer"){
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (nm/.(unit2)), sep = ""))
}else{
label_each <- bquote(paste(.(round(lm_cell$coefficients[2], 2)), " ", (.(unit1)/.(unit2)), sep = ""))
}
g_speed <- g_speed +
annotate("text", x = 0.5, y = 0.7,
label = label_each,
size = ps/ggplot2::.pt)
g_speed <- g_speed +
coord_cartesian(xlim=c(0,1), ylim=c(0,1), clip='off') +
annotate("text", x=0.5, y=1.0,
label="Signal transfer speed",
size=ps/ggplot2::.pt, fontface = 2)
glist[[length(cell_list) + 1]] <- g_speed
}
glist[[1]]
glist[[2]]
glist[[3]]
glist[[4]]
glist[[5]]
### Test the package
devtools::document()
install.packages("../cellssm", repos = NULL, type = "source")
# Load packages
library(cellssm)
# Create an output directory
out <- "07_lm_signal"
if(file.exists(out)==F){
dir.create(out, recursive=T)
}
# Linear regression
glist <- lm_signal(cell_list = cell_list, mvtime = mvtime,
ex_name = "microbeam", unit1 = "micrometer", unit2 = "min")
# Save output
g <- glist[[1]] + glist[[2]] + glist[[3]] + glist[[4]] + glist[[5]] + glist[[6]] +
plot_layout(ncol = 3)
suppressWarnings(ggsave(paste0(out, "/individual_chloroplast_lm_signal.pdf"),
g, height = 110, width = 50*3, units = "mm"))
### Test the package
devtools::document()
install.packages("../cellssm", repos = NULL, type = "source")
# Load packages
library(cellssm)
# Create an output directory
out <- "06_lm_dist_start"
if(file.exists(out)==F){
dir.create(out, recursive=T)
}
# dist vs. start
glist <- lm_dist_start(cell_list = cell_list, mvtime = mvtime,
ex_name = "microbeam", unit1 = "micrometer", unit2 = "min")
# Save output
g <- glist[[1]] + glist[[2]] + glist[[3]] + glist[[4]] + glist[[5]] +
patchwork::plot_layout(ncol = 3)
ggsave(paste0(out, "/individual_chloroplast_lm_dist_start.pdf"),
g, height = 110, width = 50*3, units = "mm")
# Load packages
library(cellssm)
# Create an output directory
out <- "07_lm_signal"
if(file.exists(out)==F){
dir.create(out, recursive=T)
}
# Linear regression
glist <- lm_signal(cell_list = cell_list, mvtime = mvtime,
ex_name = "microbeam", unit1 = "micrometer", unit2 = "min")
# Save output
g <- glist[[1]] + glist[[2]] + glist[[3]] + glist[[4]] + glist[[5]] + glist[[6]] +
plot_layout(ncol = 3)
suppressWarnings(ggsave(paste0(out, "/individual_chloroplast_lm_signal.pdf"),
g, height = 110, width = 50*3, units = "mm"))
# Create an output directory
out <- "05_lm_dist_beta"
if(file.exists(out)==F){
dir.create(out, recursive=T)
}
## Bayes
# Load data of chloroplast movements
mvtime <- as.data.frame(data.table::fread(
"02_ssm_individual/csv/ssm_individual_chloroplast_mvtime.csv"))
# Linear regression
glist <- lm_dist_beta(cell_list = cell_list, mvtime = mvtime,
ssm_path = "02_ssm_individual",
ssm_method = "Bayes", res_name = "chloroplast",
ex_name = "microbeam", unit1 = "micrometer", unit2 = "min")
# Save output
g <- (glist[[1]] + labs(tag = "A")) + (glist[[2]] + labs(tag = "B")) +
(glist[[3]] + labs(tag = "C")) + (glist[[4]] + labs(tag = "D")) +
(glist[[5]] + labs(tag = "E")) +
patchwork::plot_layout(nrow = 2)
suppressWarnings(ggsave(paste0(out, "/individual_chloroplast_lm_dist_beta.pdf"),
g, height = 104, width = 168, units = "mm"))
### Test the package
devtools::document()
### Test the package
devtools::document()
devtools::build_manual()
usethis::use_testthat()
devtools::check()
### Test the package
devtools::document()
devtools::check()
#install.packages("devtools")
devtools::install_github("hnishio/cellssm")
### Test the package
devtools::document()
devtools::check()
#install.packages("devtools")
devtools::install_github("hnishio/cellssm")
### Test the package
devtools::document()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
# Load packages
library(cellssm)
# Set the path to which CmdStan was installed
cmdstanr::set_cmdstan_path("~/cmdstan/")
# Load data
data("cell1", "cell2", "cell3", "cell4", "visual")
cell_list <- list(cell1, cell2, cell3, cell4)
test<-list(cell2[,c(1,2,4)])
ssm_individual(cell_list = test, out = "02_ssm_individual_test",
res_name = "chloroplast", ex_name = "microbeam",
unit1 = "micrometer", unit2 = "min",
df_idx = c(2), res_idx = c(2), stepwise = F)
ssm_individual(cell_list = test, out = "02_ssm_individual_test",
res_name = "chloroplast", ex_name = "microbeam",
unit1 = "micrometer", unit2 = "min",
df_idx = c(2), res_idx = c(2), stepwise = T)
# Run once to configure package to use pkgdown
usethis::use_pkgdown()
# Run to build the website
pkgdown::build_site()
usethis::use_pkgdown_github_pages()
### Test the package
devtools::document()
devtools::check()
# Run to build the website
pkgdown::build_site()
usethis::use_pkgdown_github_pages()
devtools::check()
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
#install.packages("../cellssm", repos = NULL, type = "source")
#install.packages("devtools")
devtools::install_github("hnishio/cellssm")
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
### Test the package
devtools::document()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
stepwise=60
stepwise%in%c(95, 90, 80, 70, 60, 50)
stepwise=30
stepwise%in%c(95, 90, 80, 70, 60, 50)
!stepwise%in%c(95, 90, 80, 70, 60, 50)
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
devtools::build_manual()
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
# Load packages
library(cellssm)
# Load data
data("chloroplasts")
help(nomodel)
data("cell1", "cell2", "cell3", "cell4", "visual")
cell_list <- list(cell1, cell2, cell3, cell4)
out = "04_nomodel"
res_name = "chloroplast"
ex_name = "microbeam"
unit1 = "micrometer"
unit2 = "min"
visual = visual
## Binding variables locally to the function
index <- x <- y <- NULL
# Prepare a container for movement time
df_mv <- data.frame(NULL)
i=1
j=1
Y = cell_list[[i]][,j+2]
Y
## Estimate the start of movement
## definition1: approaching to light
st_index <- min(which(cell_list[[i]]$ex == 1)) : max(which(cell_list[[i]]$ex == 1))
st_index1 <- st_index[Y[st_index] > Y[st_index+1]] # decrease at the next point
st_index1 <- st_index1[-length(st_index1)]
st_index
st_index1
## definition2: moving average of differences (sma_period points) are negative
diff <- diff(Y[st_index]) #difference between adjacent data
sma <- NULL
diff
sma <- NULL
(length(diff)-(sma_period-1))
sma_period = 10
fold = 2
(length(diff)-(sma_period-1))
k=1
k:(k+(sma_period-1))
for(k in 1:(length(diff)-(sma_period-1))){
sma[k] <- mean(diff[k:(k+(sma_period-1))]) # sma of next sma_period differences
}
sma
length(diff)
diff(sma)
which.min(diff(sma))
st_index2 <- st_index[which(sma < 0)]
st_index2
plot(diff)
plot(diff, type="l")
plot(sma, type="l")
sma_period=5
## definition2: moving average of differences (sma_period points) are negative
diff <- diff(Y[st_index]) #difference between adjacent data
sma <- NULL
for(k in 1:(length(diff)-(sma_period-1))){
sma[k] <- mean(diff[k:(k+(sma_period-1))]) # sma of next sma_period differences
}
plot(sma, type="l")
which.min(diff(sma))
diff(sma)
sp <- smooth.spline(1:length(diff), diff, spar=0.5)
pred <- predict(sp, 1:length(diff))
pred
pred <- predict(sp, 1:length(diff))$y
lines(pred)
pred
which.min(diff(pred))
## definition3: difference from the data after 5 tp is larger than fold*5/N_ex times of max - min
N_ex <- sum(cell_list[[i]]$ex == 1)
st_index3 <- st_index[(Y[st_index] - Y[st_index+5]) >
(fold*5/N_ex)*(max(Y[st_index]) - min(Y[st_index]))]
st_index3 <- st_index3[-((length(st_index3)-4):length(st_index3))]
## Overlap of def1, def2 and def3
st_index1_2 <- intersect(st_index1, st_index2)
st_index1_2_3 <- intersect(st_index1_2, st_index3)
st_index_first <- min(st_index1_2_3, na.rm = T)
st_index_last <- max(st_index1_2_3, na.rm = T)
start_time <- cell_list[[i]]$time[st_index_first] #time at st_index_first
end_time <- cell_list[[i]]$time[st_index_last] #time at st_index_last
move_time <- end_time - start_time
start_time
end_time
lines(diff(pred), col="red")
which.max(diff(pred))
cell_list[[i]]$time[st_index_first]
cell_list[[i]]$time[st_index_last]
st_index_first <- which.min(diff(pred))
st_index_last <- which.max(diff(pred))
cell_list[[i]]$time[st_index_first]
st_index
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
cell_list[[i]]$time[st_index_first]
cell_list[[i]]$time[st_index_last]
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
help("predict")
help("smooth.spline")
### Test the package
devtools::document()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
# Load packages
library(cellssm)
help(nomodel)
data("cell1", "cell2", "cell3", "cell4", "visual")
cell_list <- list(cell1, cell2, cell3, cell4)
# Prepare a container for movement time
df_mv <- data.frame(NULL)
i=1
j=12
## Estimate the start of movement
## definition1: approaching to light
st_index <- min(which(cell_list[[i]]$ex == 1)) : max(which(cell_list[[i]]$ex == 1))
## definition2: moving average of differences (sma_period points) are negative
diff <- diff(Y[st_index]) #difference between adjacent data
Y = cell_list[[i]][,j+2]
## Estimate the start of movement
## definition1: approaching to light
st_index <- min(which(cell_list[[i]]$ex == 1)) : max(which(cell_list[[i]]$ex == 1))
## definition2: moving average of differences (sma_period points) are negative
diff <- diff(Y[st_index]) #difference between adjacent data
sp <- stats::smooth.spline(1:length(diff), diff, spar=0.5)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
start_time <- cell_list[[i]]$time[st_index_first] #time at st_index_first
end_time <- cell_list[[i]]$time[st_index_last] #time at st_index_last
move_time <- end_time - start_time
start_time
plot(diff)
lines(pred)
lines(diff(pred), col="red")
sp <- stats::smooth.spline(1:length(diff), diff, spar=0.3)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
plot(diff)
lines(pred)
sp <- stats::smooth.spline(1:length(diff), diff, spar=0.8)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
plot(diff)
lines(pred)
lines(diff(pred), col="red")
start_time <- cell_list[[i]]$time[st_index_first] #time at st_index_first
end_time <- cell_list[[i]]$time[st_index_last] #time at st_index_last
move_time <- end_time - start_time
start_time
sp <- stats::smooth.spline(1:length(diff), diff, spar=0.5)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
plot(diff)
lines(pred)
lines(diff(pred), col="red")
sp <- stats::smooth.spline(1:(length(diff)+1), c(diff,0), spar=0.5)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
plot(diff)
lines(pred)
sp <- stats::smooth.spline(1:(length(diff)+3), c(diff,0,0,0), spar=0.5)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
lines(pred)
sp <- stats::smooth.spline(1:(length(diff)+10), c(diff,rep(0,10)), spar=0.5)
pred <- stats::predict(sp, 1:length(diff))$y
st_index_first <- st_index[which.min(diff(pred))]
st_index_last <- st_index[which.max(diff(pred))]
lines(pred)
lines(diff(pred), col="red")
cell_list[[i]]$time[st_index_first]
### Test the package
devtools::document()
install.packages("../cellssm", repos = NULL, type = "source")
### Test the package
devtools::document()
devtools::build_manual()
devtools::check()
install.packages("../cellssm", repos = NULL, type = "source")
